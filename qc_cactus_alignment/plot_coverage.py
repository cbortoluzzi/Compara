#!/usr/bin/env python



# Author : @cb46


import argparse
from ete3 import Tree
from pathlib import Path
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from collections import defaultdict



parser = argparse.ArgumentParser(description = 'Plot coverage of a hundred 1 Mb regions randomly sampled along a species genome')
parser.add_argument('--species_list' , help = 'Tab delimited species list file')
parser.add_argument('--refGenome', help = 'Name of reference genome')
parser.add_argument('--cov', help = 'Directory to reference genome with all coverage files as generated by maf_stream coverage')
parser.add_argument('--bp', help = 'Length of the region in base pairs [default = 1000000]', type = int, default = 1000000)
parser.add_argument('--t', help = 'Phylogenetic tree')
parser.add_argument('--o', help = 'Output directory')



def order_species_following_phylogenetic_tree(tree, cov_f, bp):
	cov_d = defaultdict(list)
	t = Tree(tree)
	# Reroot the tree to the outgroup
	t.set_outgroup('Hydropsyche_tenuis')
	for node in t.traverse('postorder'):
		if node.is_leaf():
			coverage = get_coverage(node.name, cov_f, cov_d, bp)
	return coverage



def get_coverage(node, files, dictionary, base_pairs):
	for file in files:
		with open(file) as f:
			# Skip header
			next(f)
			for line in f:
				query, target, lengthOfReference, percentCoverage, basesCoverage = line.strip().split()
				species = '_'.join(target.split('_', 2)[0:2]).capitalize()
				basesCoverage = int(basesCoverage)
				if species == node:
					coverage = round((basesCoverage/base_pairs)*100, 2)
					dictionary[species].append(coverage)
	return dictionary



def get_species_group(species_list):
	superfamilies = {}
	with open(species_list) as f:
		for line in f:
			assembly, tol_id, phylo_class, species_name, superfamily = line.strip().split()
			superfamilies[species_name] = superfamily
	return superfamilies



def plot_coverage(coverage, superfamilies, path, refGenome, species_name):
	list_species, list_coverage, list_superfamily = [], [], []
	for species in coverage:
		list_superfamily.append(superfamilies[species])
		list_species.append(species)
		list_coverage.append(coverage[species])
	# Manually create colors following Wright et al.
	list_colors = {'Noctuoidea': '#B1C968', 'Bombycoidea': '#C5A07A', 'Geometroidea': '#DB98AE', 'Drepanoidea': '#8AB1C9', 'Pyraloidea': '#ECC978', 'Papilionoidea': '#66C2A5', 'Hesperioidea': '#B3B3B3', 'Gelechioidea': '#DD927E', 
        'Zygaeinoidea': '#FCD738', 'Cossoidea': '#BE93C6', 'Torticoidea': '#CED843', 'Tineoidea': '#979EC1'}
	fig, ax = plt.subplots(figsize=(15, 8))
	bplot = ax.boxplot(list_coverage, positions=range(len(list_coverage)), labels=list_species, notch=True)
	plt.xticks(rotation = 90, ha = 'right', fontsize = 8)
	plt.ylabel('Coverage %')
	colors = [list_colors[superfamily] for superfamily in list_superfamily]
	for artist, color in zip(bplot['boxes'], colors):
		patch = mpatches.PathPatch(artist.get_path(), color=color)
		ax.add_artist(patch)
	plt.title(species_name)
	figure = Path(path, refGenome + '_coverage.pdf')
	plt.savefig(figure, dpi = 500, bbox_inches = 'tight')



if __name__ == "__main__":
	args = parser.parse_args()
	# List of coverage files
	cov_f = list(Path(args.cov).rglob('*.cov'))
	# Generate output directory if it doesn't extist
	p = Path(args.o)
	p.mkdir(parents=True, exist_ok=True)
	species_name = '_'.join(args.refGenome.split('_')[0:2]).capitalize()
	# Obtain coverage for each species, following their phylogenetic placement
	coverage_species = order_species_following_phylogenetic_tree(args.t, cov_f, args.bp)
	# Obtain name of superfamily each species belongs to
	species_superfamily = get_species_group(args.species_list)
	# Plot coverage
	plot = plot_coverage(coverage_species, species_superfamily, args.o, args.refGenome, species_name)

	
